arr = [10, 6, 4, 5, 1, 3, 2, 9, 7, 8] # 힙에다 넣을 것

# max heap
heap = [0] * 11
# 마지막에 넣을 원소 위치를 비교할 변수가 필요하다
last = 0

# 삽입연산
def enq(item):
    global last
    last += 1 # 마지막 위치에 원소 추가
    heap[last] = item # 일단 넣고 그 자리가 맞는지 본다

    # 원소 추가 후에 부모노드 > 자식노드 조건을 만족하도록 작업함
    # 현재 위치를 자식 노드로 생각
    # 부모노드의 위치를 계산한다 (2로 나누면 해당값)
    c = last
    p = c // 2
    # 부모노드가 존재하고, 자식노드가 부모 노드보다 작을 때까지 위치를 바꿈
    while p and heap[p] < heap[c]:
        heap[p], heap[c] = heap[c], heap[p]
        # 그 위에 부모랑도 비교해야 함
        # 바뀌었으니까 부모-자식 위치 그 위로 바꾸고 계속 비교 이어가기
        c = p
        p = c // 2

# 삭제연산
def deq():
    # 마지막 원소 들어갈 위치 조정이 필요함
    global last

    # 반환하면 끝이 아니라 다시 또 제일 큰 값이 제일 위로 오게 조정해야함.
    # 일단 마지막에 있는거 가져와서 또 자리바꾸기 해서 정렬함

    # 루트노드를 삭제할건데- heap의 현재 루트노드를 임시로 저장해두고 작업함
    temp = heap[1]

    # 마지막 노드를 루트 위치에 땡겨온다 -덮어씌워버림
    heap[1] = heap[last]

    # 원소 하나를 삭제했으니. last를 가져왔으니까 last는 지금 뭐가 없음 - last 조정
    last -= 1

    # root부터 자리를 찾아가기 시작
    # 부모를 기준으로
    p = 1
    c = p * 2 # 일단 왼쪽 자식부터 비교->왼쪽부터 하는 이유? 왼쪽부터 채워나가니까(완전이진트리)

    # 자리 조정
    # 최대 힙은 부모가 자식보다 크다 -> 부모가 자식보다 작으면 자리바꿔야함
    # 자식이 없는 경우 비교 불가
    # 왼쪽 자식의 인덱스가 last보다 작아야 트리 안에 존재하는 것
    while c <= last:
        # 왼쪽 자식이 있으면 오른쪽 자식도 있나 확인
        # max heap은 무조건 부모가 자식보다 커야 하니까
        if c + 1 <= last and heap[c] < heap[c+1]:
            # 오른쪽자식도 last이하인지 확인하고 만약 오른쪽이 왼쪽보다 크면 오른쪽이랑 비교
            c = c + 1
        if heap[p] < heap[c]:
            # 자식이 더 크면 자리를 교환
            heap[p], heap[c] = heap[c], heap[p]
            # 하향식으로 찾아내려가고있음 -> 부모 조정
            # 부모를 새로운 자식으로 생각
            p = c
            # 왼쪽 자식을 기준으로 비교 계속 하기
            c = c * 2
        # 만약 부모자 자식보다 크면 자리를 바꿀 필요가 없음
        else:  # if heap[p] > heap[c]
            # 그밑엔 어차피 나보다 작은 애들만 있음
            # 여기가 내자리다
            break
    # 반복문이 끝났다 -> 내자리 찾음
    # 루트 노드 return
    return temp



for i in range(10):
    enq(arr[i])

print(f"heap = {heap}")

sorted_arr = []

for i in range(10):
    sorted_arr.append(deq())

print(f"sorted_arr = {sorted_arr}")

# 최대힙은 순서는 중요하지 않다 그냥 꼭대기에 있는 값이 제일 크면 오케잉
