def counting_sort_asc(A, B, K):
    # A : 정렬 대상
    # B : 정렬 결과
    # K : 정렬 대상 중 최댓값(숫자 수를 셀 때 배열의 크기)
    C = [0] * (K + 1)
    # C : 카운트 배열(원소의 개수를 세주고, 자리를 정해 준다)
    # C[X] == X의 등장 횟수. C[1] => A안에 i가 몇 번 등장하는지(있는지)

    # 1. 각 원소의 등장 횟수를 센다.
    for i in range(len(A)):
        # A[i]의 등장 횟수를 하나씩 증가 시켜준다.
        C[A[i]] += 1

    # 2. 각 원소의 등장횟수를 계산해서 각 원소가 들어갈 자리의 위치를 구해준다.
    for i in range(1, len(C)):
        # i는 i보다 작은 수가 몇개 있는지를 알면 그 뒤부터 나온다는 것을 알기 때문에.
        C[i] += C[i-1]

    # 3. 뒤에서부터 A를 확인하면서 자리를 확인하고 채워준다.
    # 뒤에서부터 확인하는 이유 : 안정 정렬(원 배열의 순서 보장)
    # 자리를 채워 줄 때 마다 1씩 감소시켜야 한다(자리 덮어쓰기 방지)
    for i in range(len(B) -1, -1, -1):
        # C[A[i]] => A[i]가 들어갈 자리를 가르키고 있음. (들어가기 전에 1 빼야함)
        C[A[i]] -= 1
        # 자리에 A[i]를 넣는다.
        B[C[A[i]]] = A[i]
    
    return B

nums = [0, 4, 1, 3, 1, 2, 4, 1]

result_asc = [0] * 8



# result = counting_sort_asc(nums, result_asc, max(nums))
# print(result)
                

def nnnn(A, B, K):
    # A : 정렬 대상
    # B : 정렬 결과
    # K : 정렬 대상 중 최댓값(숫자 수를 셀 때 배열의 크기)
    C = [0] * (K + 1)
    # C : 카운트 배열(원소의 개수를 세주고, 자리를 정해 준다)
    # C[X] == X의 등장 횟수. C[1] => A안에 i가 몇 번 등장하는지(있는지)

    # 1. 각 원소의 등장 횟수를 센다.
    for i in range(len(A)):
        # A[i]의 등장 횟수를 하나씩 증가 시켜준다.
        C[A[i]] += 1

    # 2. 각 원소의 등장횟수를 계산해서 각 원소가 들어갈 자리의 위치를 구해준다.
    for i in range(1, len(C), -1):
        # i는 i보다 작은 수가 몇개 있는지를 알면 그 뒤부터 나온다는 것을 알기 때문에.
        # i보다 큰 수의 갯수를 알아야되는데.
        print(f"i = {i}")
        # C[i-1] += C[i]

        C[i] += C[i-1]

    # 3. 뒤에서부터 A를 확인하면서 자리를 확인하고 채워준다.
    # 뒤에서부터 확인하는 이유 : 안정 정렬(원 배열의 순서 보장)
    # 자리를 채워 줄 때 마다 1씩 감소시켜야 한다(자리 덮어쓰기 방지)
    for i in range(len(B) -1, -1, -1):
        # C[A[i]] => A[i]가 들어갈 자리를 가르키고 있음. (들어가기 전에 1 빼야함)
        C[A[i]] -= 1
        # 자리에 A[i]를 넣는다.
        B[C[A[i]]] = A[i]

    return B
    
result = nnnn(nums, result_asc, max(nums))
print(result)
                   